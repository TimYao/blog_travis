(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{359:function(e,v,_){"use strict";_.r(v);var t=_(33),o=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"node-介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#node-介绍"}},[e._v("#")]),e._v(" node 介绍")]),e._v(" "),_("p",[e._v("node 是一个基于chrome v8引擎的js运行的容器环境，并不是一个新语言，只是为了可以提供一个js在后端运行，node并不具有所有js提供的方法，js本身组成bom,dom,escript,只体现了基本的escript中的语法，不具有bom,dom操作，但提供了一些自身环境扩展的API，文件操作，http服务等模块，流的概念，node优势体现在异步非阻塞单线程，主要可以运用在作为中间件提供服务，做一些工具库开发，适合一些高并发操作开发(针对读写，接口操作)，Web主要场景就是接收客户端的请求读取静态资源和渲染界面,所以Node非常适合Web应用的开发")]),e._v(" "),_("h2",{attrs:{id:"js单线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#js单线程"}},[e._v("#")]),e._v(" js单线程")]),e._v(" "),_("p",[e._v("javascript在最初设计时设计成了单线程,为什么不是多线程呢？如果多个线程同时操作DOM那岂不会很混乱？这里所谓的单线程指的是主线程是单线程的,所以在Node中主线程依旧是单线程的")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("单线程特点是节约了内存,并且不需要在切换执行上下文")])]),e._v(" "),_("li",[_("p",[e._v("单线程不需要管锁的问题")])])]),e._v(" "),_("h2",{attrs:{id:"同步异步阻塞非阻塞"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#同步异步阻塞非阻塞"}},[e._v("#")]),e._v(" 同步异步阻塞非阻塞")]),e._v(" "),_("p",[e._v("同步，异步概念理解主要针对是处理方使用的方式，怎么去处理请求方发起的请求，响应是否马上能回应")]),e._v(" "),_("p",[e._v("阻塞非阻塞概念理解主要是针对发起方，是否需要等待发起请求结果，等待会阻塞后面的任务，非阻塞不需要等待，继续其他任务，体现在是否要等待响应")]),e._v(" "),_("p",[e._v("同步阻塞：发起任务方，需要等待处理放回应，处理方以同步方式处理请求")]),e._v(" "),_("p",[e._v("同步非阻塞： 发起任务方，不需要等待处理方即时回应，处理方以同步方式处理请求")]),e._v(" "),_("p",[e._v("异步阻塞：发起方会一直等待处理方返回，处理异步处理完成返回")]),e._v(" "),_("p",[e._v("异步非阻塞：发起方不需要等待处理方马上回应响应，等处理方完成会通知发起方")]),e._v(" "),_("h2",{attrs:{id:"node-中的event-loop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#node-中的event-loop"}},[e._v("#")]),e._v(" node 中的event loop")]),e._v(" "),_("p",[e._v("首先node中的event loop与浏览器间的区别不是很大，基本运行顺序要求一样，区别在于node中的宏任务有各自的队列，浏览器都会进入一个宏任务队列，node中对于任务调度访问顺序不同，timers定时器宏任务，pending callbacks上次执行剩余任务，idle, prepare ide内部任务，poll检索新的I/O事件;执行与 I/O相关的回调(io相关操作任务),check任务setImmediate，close callbacks一些关闭的回调函数")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("我们写的js代码会交给v8引擎进行处理")])]),e._v(" "),_("li",[_("p",[e._v("代码中可能会调用nodeApi,node会交给libuv库处理")])]),e._v(" "),_("li",[_("p",[e._v("libuv通过阻塞i/o和多线程实现了异步io")])]),e._v(" "),_("li",[_("p",[e._v("通过事件驱动的方式,将结果放到事件队列中,最终交给我们的应用。")])])]),e._v(" "),_("h2",{attrs:{id:"node中全局对象和模块"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#node中全局对象和模块"}},[e._v("#")]),e._v(" node中全局对象和模块")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("全局对象")]),e._v(" "),_("p",[e._v("Buffer")]),e._v(" "),_("p",[e._v("process")]),e._v(" "),_("p",[e._v("setInterval,setTimeout,setImmediate")]),e._v(" "),_("p",[e._v("console")]),e._v(" "),_("p",[e._v("queueMicrotask")])]),e._v(" "),_("li",[_("p",[e._v("模块")]),e._v(" "),_("p",[e._v("__dirname\n__filename\nmodule\nexport\nrequire")])])]),e._v(" "),_("h2",{attrs:{id:"node中模块"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#node中模块"}},[e._v("#")]),e._v(" node中模块")]),e._v(" "),_("ul",[_("li",[e._v("commonjs 规范")])]),e._v(" "),_("ol",[_("li",[_("p",[e._v("一个文件即一个模块")])]),e._v(" "),_("li",[_("p",[e._v("module.exports导出模块")])]),e._v(" "),_("li",[_("p",[e._v("require导入模块")])])]),e._v(" "),_("ul",[_("li",[e._v("模块中分类")])]),e._v(" "),_("ol",[_("li",[_("p",[e._v("核心模块，内置模块，即node内部提供的，不需要安装直接应用")])]),e._v(" "),_("li",[_("p",[e._v("第三方模块，需要安装模块，查找规则，以node_modules，module.path路径直到找到根目录下")])]),e._v(" "),_("li",[_("p",[e._v("自定义模块，需要经过模块路径解析，模块载入")])])]),e._v(" "),_("ul",[_("li",[e._v("模块实现")])]),e._v(" "),_("ol",[_("li",[e._v("模块类别区分")])]),e._v(" "),_("p",[e._v("文件模块（相对地址，绝对地址），内置模块（直接读入），第三方模块（以module.path方式递归查找）")]),e._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[e._v("模块路径解析")])]),e._v(" "),_("p",[e._v("文件模块：相对地址解析出绝对路径")]),e._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[e._v("模块查找")])]),e._v(" "),_("p",[e._v("内置模块， 文件模块，第三方模块，均初会检测优先读入缓存模块")]),e._v(" "),_("p",[e._v("文件模块：路径分析完分别以后缀(js,json,node)查找，若不存在，以目录格式下分别以index（js,json,node）后缀查找")]),e._v(" "),_("p",[e._v("第三方模块：从module.path下查找，分别以文件模式查找，不存在，以包的方式查找，package.json(main)/index(js,json,node)")]),e._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[e._v("模块创建")])]),e._v(" "),_("p",[e._v("找不到缓存下模块，读取到查找到模块内容进行创建模块，并保存到缓存模块下")]),e._v(" "),_("p",[e._v("module {\nid,  //路径\nexports // 最终内容\n.\n.\n.\n}")]),e._v(" "),_("ol",{attrs:{start:"5"}},[_("li",[e._v("模块加载")])])])}),[],!1,null,null,null);v.default=o.exports}}]);